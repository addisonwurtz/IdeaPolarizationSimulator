Index: IdeaPolarizationSim/simulation_classes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from random import random\r\n\r\n\r\nclass SocialNetwork:\r\n    def __init__(self, graph, users: [], news_items: [], update_rate):\r\n        self.graph = graph\r\n        self.users = users\r\n        self.news_items = news_items\r\n        self.update_rate = update_rate\r\n\r\n    def probability_of_infection(self, user, neighbor, news_item):\r\n        edge_weight = self.graph.get_edge_weight(user, neighbor)\r\n        selective_exposure = (1 - edge_weight) * (1 - abs(news_item.opinion_score - neighbor.opinion_score))\r\n        return (edge_weight ** 2) + selective_exposure\r\n\r\n    def share_news_item(self, user, news_item):\r\n        connections: [User] = user.get_connections()\r\n        for connection in connections:\r\n            if connection not in news_item.inoculated_users:\r\n                if random() < self.probability_of_infection(user, connection, news_item):\r\n                    news_item.infect_user(connection)\r\n                    connection.update_opinion(news_item.opinion_score)\r\n                    self.graph.increase_connection_strength(user, connection)\r\n                else:\r\n                    self.graph.decrease_connection_strength(user, connection)\r\n        news_item.remove_user_from_infectious_list(user)\r\n\r\n\r\nclass Graph:\r\n    def __init__(self, nodes: [], edges: [], edge_weights: {}):\r\n        self.nodes = nodes\r\n        self.edge_weights = edge_weights\r\n        self.edges = edges\r\n\r\n    def increase_connection_strength(self, sender, receiver):\r\n        edge_string = self.get_edge_tuple(sender, receiver)\r\n        edge_weight = self.edge_weights[edge_string]\r\n        self.edge_weights[edge_string] = edge_weight + self.update_rate\r\n\r\n    def decrease_connection_strength(self, sender, receiver):\r\n        edge_string = self.get_edge_tuple(sender, receiver)\r\n        edge_weight = self.edge_weights[edge_string]\r\n        self.edge_weights[edge_string] = edge_weight - self.update_rate\r\n\r\n    @staticmethod\r\n    def get_edge_tuple(user1, user2):\r\n        edge_tuple: (int, int) = (user1.user_id, user2.user_id)\r\n        return edge_tuple\r\n\r\n    def get_edge_weight(self, user1, user2):\r\n        edge = self.get_edge_tuple(user1, user2)\r\n        return self.edge_weights[edge]\r\n\r\n\r\nclass User:\r\n    def __init__(self, user_id: int, opinion_score: float, connections, update_rate=0.1):\r\n        self.user_id: int = user_id\r\n        self.opinion_score: float = opinion_score\r\n        self.connections: [User] = connections\r\n        self.update_rate: float = update_rate\r\n\r\n    def get_connections(self):\r\n        return self.connections\r\n\r\n    def add_connections(self, new_connections):\r\n        self.connections += new_connections\r\n\r\n    def update_opinion(self, news_opinion_score):\r\n        if news_opinion_score > self.opinion_score:\r\n            self.opinion_score += self.update_rate * news_opinion_score\r\n        elif news_opinion_score < self.opinion_score:\r\n            self.opinion_score -= self.update_rate * news_opinion_score\r\n\r\n\r\nclass NewsItem:\r\n    def __init__(self, opinion_score: float, initial_spreader_nodes: [User]):\r\n        self.opinion_score: float = opinion_score\r\n        self.initial_spreader_nodes: [User] = initial_spreader_nodes\r\n        self.infectious_users: [User] = initial_spreader_nodes\r\n        self.inoculated_users: [User] = initial_spreader_nodes\r\n\r\n    def infect_user(self, neighbor: User):\r\n        if neighbor not in self.inoculated_users:\r\n            self.infectious_users.append(neighbor)\r\n            self.inoculated_users.append(neighbor)\r\n\r\n    def remove_user_from_infectious_list(self, user: User):\r\n        if user in self.infectious_users:\r\n            self.infectious_users.remove(user)\r\n\r\n    def update_inoculated_nodes(self):\r\n        for node in self.infectious_users:\r\n            if node not in self.inoculated_users:\r\n                self.inoculated_users.append(node)\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IdeaPolarizationSim/simulation_classes.py b/IdeaPolarizationSim/simulation_classes.py
--- a/IdeaPolarizationSim/simulation_classes.py	(revision 7fcd1e48c319ff9a9b53177b2e1b560f6d4bc320)
+++ b/IdeaPolarizationSim/simulation_classes.py	(date 1668480586936)
@@ -14,6 +14,9 @@
         return (edge_weight ** 2) + selective_exposure
 
     def share_news_item(self, user, news_item):
+        if user not in news_item.infectious_users:
+            raise UserNotInfectiousError(f'user {user.user_id} is not in the infectious user list for news item '
+                                         f'{news_item.item_id}')
         connections: [User] = user.get_connections()
         for connection in connections:
             if connection not in news_item.inoculated_users:
@@ -27,10 +30,11 @@
 
 
 class Graph:
-    def __init__(self, nodes: [], edges: [], edge_weights: {}):
+    def __init__(self, nodes: [], edges: [], edge_weights: {}, update_rate=0.1):
         self.nodes = nodes
-        self.edge_weights = edge_weights
+        self.edge_weights: {} = edge_weights
         self.edges = edges
+        self.update_rate = update_rate
 
     def increase_connection_strength(self, sender, receiver):
         edge_string = self.get_edge_tuple(sender, receiver)
@@ -73,14 +77,15 @@
 
 
 class NewsItem:
-    def __init__(self, opinion_score: float, initial_spreader_nodes: [User]):
+    def __init__(self, item_id: int, opinion_score: float, initial_spreader_nodes: [User]):
+        self.item_id = item_id
         self.opinion_score: float = opinion_score
         self.initial_spreader_nodes: [User] = initial_spreader_nodes
         self.infectious_users: [User] = initial_spreader_nodes
         self.inoculated_users: [User] = initial_spreader_nodes
 
     def infect_user(self, neighbor: User):
-        if neighbor not in self.inoculated_users:
+        if neighbor not in self.inoculated_users and neighbor not in self.infectious_users:
             self.infectious_users.append(neighbor)
             self.inoculated_users.append(neighbor)
 
@@ -88,9 +93,6 @@
         if user in self.infectious_users:
             self.infectious_users.remove(user)
 
-    def update_inoculated_nodes(self):
-        for node in self.infectious_users:
-            if node not in self.inoculated_users:
-                self.inoculated_users.append(node)
 
-
+class UserNotInfectiousError(Exception):
+    pass
Index: Tests/test_simulation_classes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\r\nfrom IdeaPolarizationSim.simulation_classes import Graph, User, NewsItem\r\nfrom IdeaPolarizationSim.toy_graph import *\r\n\r\nclass TestGraph(unittest.TestCase):\r\n    def test_graph(self):\r\n\r\n        graph = Graph(nodes, edge_weights, 0.1)\r\n        self.assertIn(user_1, graph.nodes)\r\n        self.assertIn(user_5, graph.nodes)\r\n        self.assertEqual(graph.edge_weights[(1, 2)], 0.8)\r\n        self.assertEqual(graph.edge_weights[(3, 4)], 0.3)\r\n        self.assertEqual(graph.update_rate, 0.1)\r\n\r\n\r\nclass TestUser(unittest.TestCase):\r\n    def test_valid_user(self):\r\n        test_user = User(1, 0.75, [])\r\n        self.assertIsInstance(test_user.user_id, int)\r\n        self.assertIsInstance(test_user.opinion_score, float)\r\n\r\n    def test_invalid_user(self):\r\n        self.assertRaises(TypeError, User('name', -1.0, []))\r\n        self.assertRaises(TypeError, User(2, 'something else', []))\r\n\r\n\r\nclass TestNewsItem(unittest.TestCase):\r\n    def test_valid_news_item(self):\r\n        test_news_item = NewsItem(.5, [])\r\n        self.assertIsInstance(test_news_item.opinion_score, float)\r\n\r\n    def test_invalid_news_item(self):\r\n        self.assertRaises(TypeError, NewsItem('good', ['apple', 'banana']))\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Tests/test_simulation_classes.py b/Tests/test_simulation_classes.py
--- a/Tests/test_simulation_classes.py	(revision 7fcd1e48c319ff9a9b53177b2e1b560f6d4bc320)
+++ b/Tests/test_simulation_classes.py	(date 1668480479588)
@@ -1,16 +1,109 @@
 import unittest
-from IdeaPolarizationSim.simulation_classes import Graph, User, NewsItem
-from IdeaPolarizationSim.toy_graph import *
+from unittest.mock import Mock, patch
+from IdeaPolarizationSim.simulation_classes import NewsItem, User, Graph, SocialNetwork, UserNotInfectiousError
+
+
+class TestSocialNetwork(unittest.TestCase):
+    def test_probability_of_infection(self):
+        from IdeaPolarizationSim import toy_graph
+        news_item = NewsItem(1, 0.8, [])
+        social_network = SocialNetwork(toy_graph.graph, toy_graph.nodes, news_item, 0.1)
+
+        self.assertEqual(0.89, social_network.probability_of_infection(toy_graph.user_1, toy_graph.user_3, news_item))
+
+    def test_share_news_item(self):
+        from IdeaPolarizationSim import toy_graph
+        news_item = NewsItem(1, 0.8, [toy_graph.user_4])
+        social_network = SocialNetwork(toy_graph.graph, news_item, 0.1)
+
+        with patch('IdeaPolarizationSim.simulation_classes.SocialNetwork.probability_of_infection') \
+                as mock_probability_of_infection:
+            mock_probability_of_infection.return_value = 1
+            social_network.share_news_item(toy_graph.user_4, news_item)
+
+            for connection in toy_graph.user_4.connections:
+                self.assertIn(connection, news_item.inoculated_users)
+                self.assertIn(connection, news_item.infectious_users)
+
+            self.assertNotIn(toy_graph.user_4, news_item.infectious_users)
+            self.assertIn(toy_graph.user_4, news_item.inoculated_users)
+
+    def test_share_news_item_raises_error_for_user_not_in_infectious_list(self):
+        from IdeaPolarizationSim import toy_graph
+        news_item = NewsItem(0.8, [])
+        user = Mock()
+        social_network = SocialNetwork(toy_graph.graph, toy_graph.nodes, news_item, 0.1)
+
+        with self.assertRaises(UserNotInfectiousError):
+            social_network.share_news_item(user, news_item)
+
 
 class TestGraph(unittest.TestCase):
     def test_graph(self):
+        from IdeaPolarizationSim import toy_graph
+
+        test_graph = Graph(toy_graph.nodes, toy_graph.edge_weights, 0.1)
+        self.assertIn(toy_graph.user_1, test_graph.nodes)
+        self.assertIn(toy_graph.user_5, test_graph.nodes)
+        self.assertEqual(test_graph.edge_weights[(1, 2)], 0.8)
+        self.assertEqual(test_graph.edge_weights[(3, 4)], 0.3)
+        self.assertEqual(test_graph.update_rate, 0.1)
+
+    def test_increase_connection_strength(self):
+        user1 = User(1, 0.75, [])
+        user2 = User(2, -0.5, [user1])
+        user1.add_connections([user2])
+        edges = (1, 2)
+        edge_weight = {(1, 2) : 0.5}
+        test_graph = Graph([user1, user2], edges, edge_weight, update_rate=0.1)
+
+        test_graph.increase_connection_strength(user1, user2)
+        self.assertEqual(0.6, test_graph.edge_weights[(1, 2)])
+
+    def test_decrease_connection_strength(self):
+        user1 = User(1, 0.75, [])
+        user2 = User(2, -0.5, [user1])
+        user1.add_connections([user2])
+        edge_weight = {(1, 2): 0.5}
+        test_graph = Graph([user1, user2], edge_weight, update_rate=0.1)
+
+        test_graph.decrease_connection_strength(user1, user2)
+        self.assertEqual(0.4, test_graph.edge_weights['1-2'])
+
+    def test_get_edge_string(self):
+        user1 = User(1, 0.2, [])
+        user2 = User(2, -0.4, [])
+
+        self.assertEqual((1, 2), Graph.get_edge_string(user1, user2))
+        self.assertEqual((1, 2), Graph.get_edge_string(user2, user1))
+
+    def test_get_edge_string_raises_value_error_when_nodes_are_the_same(self):
+        user = Mock()
+        with self.assertRaises(ValueError):
+            Graph.get_edge_string(user, user)
+
+    def test_get_edge_weight_for_valid_edge(self):
+        user1 = User(1, 0.2, [])
+        user2 = User(2, -0.4, [])
+        edge_weight = {(1, 2): 0.65}
+
+        test_graph = Graph([user1, user2], edge_weight)
 
-        graph = Graph(nodes, edge_weights, 0.1)
-        self.assertIn(user_1, graph.nodes)
-        self.assertIn(user_5, graph.nodes)
-        self.assertEqual(graph.edge_weights[(1, 2)], 0.8)
-        self.assertEqual(graph.edge_weights[(3, 4)], 0.3)
-        self.assertEqual(graph.update_rate, 0.1)
+        self.assertEqual(0.65, test_graph.get_edge_weight(user1, user2))
+        self.assertEqual(0.65, test_graph.get_edge_weight(user2, user1))
+
+    def test_get_edge_weight_catches_value_error_when_args_Are_the_same_node(self):
+        user = Mock()
+        test_graph = Graph(user, {})
+        with self.assertRaises(ValueError):
+            test_graph.get_edge_weight(user, user)
+
+    def test_get_edge_weight_on_edge_not_in_graph(self):
+        user1 = Mock()
+        user2 = Mock()
+        test_graph = Graph(user1, {})
+        with self.assertRaises(KeyError):
+            test_graph.get_edge_weight(user1, user2)
 
 
 class TestUser(unittest.TestCase):
@@ -23,14 +116,104 @@
         self.assertRaises(TypeError, User('name', -1.0, []))
         self.assertRaises(TypeError, User(2, 'something else', []))
 
+    def test_get_connections(self):
+        connection1 = User(2, 0.5, [])
+        connection2 = User(3, 1, [])
+        connections = [connection1, connection2]
+        test_user = User(1, 0.75, connections)
+
+        self.assertEqual(test_user.get_connections(), connections)
+
+    def test_add_connections_with_list(self):
+        test_user = User(1, 0.75, [])
+        connection1 = User(2, 0.5, [])
+        connection2 = User(3, 1, [])
+        connection3 = User(4, 0.15, [])
+        connections = [connection1, connection2, connection3]
+
+        test_user.add_connections(connections)
+
+        self.assertIn(connection1, test_user.connections)
+        self.assertIn(connection2, test_user.connections)
+        self.assertIn(connection3, test_user.connections)
+
+    def test_add_connections_by_adding_single_new_connection_to_existing_list(self):
+        connection1 = User(2, 0.5, [])
+        connection2 = User(3, 1, [])
+        connection3 = User(4, 0.15, [])
+        connections = [connection1, connection2, connection3]
+        test_user = User(1, 0.75, connections)
+
+        new_connection = User(5, 0.9, [])
+        test_user.add_connections([new_connection])
+
+        self.assertIn(new_connection, test_user.connections)
+
+    def test_update_opinion_to_increase_opinion_score(self):
+        opinion_update_rate = 0.1
+        news_item_opinions_score = 1.0
+        test_user = User(1, 0.75, [], opinion_update_rate)
+        test_user.update_opinion(news_item_opinions_score)
+
+        self.assertEqual(test_user.opinion_score, 0.75 + opinion_update_rate * news_item_opinions_score)
+
+    def test_update_opinion_to_decrease_opinion_score(self):
+        opinion_update_rate = 0.1
+        news_item_opinions_score = -1.0
+        test_user = User(1, 0.75, [], opinion_update_rate)
+        test_user.update_opinion(news_item_opinions_score)
+
+        self.assertEqual(test_user.opinion_score, 0.75 - opinion_update_rate * news_item_opinions_score)
+
 
 class TestNewsItem(unittest.TestCase):
     def test_valid_news_item(self):
-        test_news_item = NewsItem(.5, [])
+        test_news_item = NewsItem(1, 0.5, [])
         self.assertIsInstance(test_news_item.opinion_score, float)
 
     def test_invalid_news_item(self):
-        self.assertRaises(TypeError, NewsItem('good', ['apple', 'banana']))
+        self.assertRaises(TypeError, NewsItem(1, 'good', ['apple', 'banana']))
+
+    def test_infect_user_updates_infectious_and_inoculated_lists(self):
+        user = User(1, 0.5, [])
+        news_item = NewsItem(1, 0.3, [])
+
+        news_item.infect_user(user)
+
+        self.assertIs(user, news_item.infectious_users[0])
+        self.assertIn(user, news_item.infectious_users)
+        self.assertIn(user, news_item.inoculated_users)
+
+    def test_infect_user_does_not_add_duplicates_to_infectious_and_inoculated_lists(self):
+        user = User(1, 0.5, [])
+        news_item = NewsItem(1, 0.3, [])
+
+        news_item.infect_user(user)
+        news_item.infect_user(user)
+
+        self.assertEqual(1, news_item.infectious_users.count(user))
+        self.assertEqual(1, news_item.inoculated_users.count(user))
+
+    def test_infect_user_does_not_add_user_that_is_inoculated_but_not_infectious(self):
+        user = User(1, 0.5, [])
+        news_item = NewsItem(1, 0.3, [])
+
+        news_item.infect_user(user)
+        news_item.remove_user_from_infectious_list(user)
+        news_item.infect_user(user)
+
+        self.assertNotIn(user, news_item.infectious_users)
+        self.assertIn(user, news_item.inoculated_users)
+
+    def test_remove_user_from_infectious_list_removes_user(self):
+        user = User(1, 0.5, [])
+        news_item = NewsItem(1, 0.3, [])
+
+        news_item.infect_user(user)
+        news_item.remove_user_from_infectious_list(user)
+
+        self.assertNotIn(user, news_item.infectious_users)
+        self.assertIn(user, news_item.inoculated_users)
 
 
 if __name__ == '__main__':
Index: IdeaPolarizationSim/simulation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from random import random\r\nfrom IdeaPolarizationSim.simulation_classes import SocialNetwork\r\nfrom IdeaPolarizationSim.simulation_classes import Graph\r\nfrom IdeaPolarizationSim.simulation_classes import User\r\nfrom IdeaPolarizationSim.simulation_classes import NewsItem\r\n\r\n\r\nimport toy_graph\r\n\r\nupdate_rate = 0.1\r\nusers: [User] = toy_graph.nodes\r\nnews_items: [NewsItem] = [NewsItem(0, [toy_graph.user_1, toy_graph.user_6])]\r\n\r\nsocial_network = SocialNetwork(toy_graph.graph, users, news_items, update_rate)\r\n\r\ntime = 1\r\n\r\nfor news_item in social_network.news_items:\r\n\r\n    print(f'Nodes that can spread news item: {[user.user_id for user in news_item.infectious_users]}')\r\n    print(f'Nodes that have been infected by news item: {[user.user_id for user in news_item.inoculated_users]}')\r\n\r\n    for user in news_item.infectious_users:\r\n        social_network.share_news_item(user, news_item)\r\n\r\n    time += 1\r\n\r\nfor news_item in social_network.news_items:\r\n    print(f'Number of users infected with story: {len(news_item.inoculated_users)}')\r\n    print(f'Users infected with story: {[inoculated_user.user_id for inoculated_user in news_item.inoculated_users]}')\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/IdeaPolarizationSim/simulation.py b/IdeaPolarizationSim/simulation.py
--- a/IdeaPolarizationSim/simulation.py	(revision 7fcd1e48c319ff9a9b53177b2e1b560f6d4bc320)
+++ b/IdeaPolarizationSim/simulation.py	(date 1668479238609)
@@ -9,9 +9,9 @@
 
 update_rate = 0.1
 users: [User] = toy_graph.nodes
-news_items: [NewsItem] = [NewsItem(0, [toy_graph.user_1, toy_graph.user_6])]
+news_items: [NewsItem] = [NewsItem(1, 0, [toy_graph.user_1, toy_graph.user_6])]
 
-social_network = SocialNetwork(toy_graph.graph, users, news_items, update_rate)
+social_network = SocialNetwork(toy_graph.graph, news_items, update_rate)
 
 time = 1
 
@@ -21,14 +21,17 @@
     print(f'Nodes that have been infected by news item: {[user.user_id for user in news_item.inoculated_users]}')
 
     for user in news_item.infectious_users:
-        social_network.share_news_item(user, news_item)
+        try:
+            social_network.share_news_item(user, news_item)
+        except Exception as e:
+            print(e)
 
     time += 1
 
 for news_item in social_network.news_items:
     print(f'Number of users infected with story: {len(news_item.inoculated_users)}')
     print(f'Users infected with story: {[inoculated_user.user_id for inoculated_user in news_item.inoculated_users]}')
-
+    print(f'Simulation time: {time}')
 
 
 
